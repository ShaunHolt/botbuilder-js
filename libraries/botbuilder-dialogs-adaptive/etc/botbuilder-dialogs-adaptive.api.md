## API Report File for "botbuilder-dialogs-adaptive"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Activity } from 'botbuilder-core';
import { ArrayExpression } from 'adaptive-expressions';
import { BeginSkillDialogOptions } from 'botbuilder-dialogs';
import { BoolExpression } from 'adaptive-expressions';
import { BotFrameworkClient } from 'botbuilder-core';
import { BotTelemetryClient } from 'botbuilder-core';
import { BuilderRegistration } from 'botbuilder-dialogs-declarative';
import { Choice } from 'botbuilder-dialogs';
import { ChoiceFactoryOptions } from 'botbuilder-dialogs';
import { ComponentRegistration } from 'botbuilder-dialogs-declarative';
import { Configurable } from 'botbuilder-dialogs';
import { Converter } from 'botbuilder-dialogs-declarative';
import { Dialog } from 'botbuilder-dialogs';
import { DialogContainer } from 'botbuilder-dialogs';
import { DialogContext } from 'botbuilder-dialogs';
import { DialogDependencies } from 'botbuilder-dialogs';
import { DialogEvent } from 'botbuilder-dialogs';
import { DialogEvents } from 'botbuilder-dialogs';
import { DialogInstance } from 'botbuilder-dialogs';
import { DialogManager } from 'botbuilder-dialogs';
import { DialogReason } from 'botbuilder-dialogs';
import { DialogSet } from 'botbuilder-dialogs';
import { DialogState } from 'botbuilder-dialogs';
import { DialogTurnResult } from 'botbuilder-dialogs';
import { Entity } from 'botbuilder-core';
import { EnumExpression } from 'adaptive-expressions';
import { Expression } from 'adaptive-expressions';
import { ExpressionParserInterface } from 'adaptive-expressions';
import { ExpressionProperty } from 'adaptive-expressions';
import { FindChoicesOptions } from 'botbuilder-dialogs';
import { Headers as Headers_2 } from 'node-fetch';
import { ImportResolverDelegate } from 'botbuilder-lg';
import { IntExpression } from 'adaptive-expressions';
import { ListStyle } from 'botbuilder-dialogs';
import { LuisPredictionOptions } from 'botbuilder-ai';
import { LuisRecognizerOptionsV3 } from 'botbuilder-ai';
import { ModelResult } from 'botbuilder-dialogs';
import { NumberExpression } from 'adaptive-expressions';
import { ObjectExpression } from 'adaptive-expressions';
import { PromptOptions } from 'botbuilder-dialogs';
import { QnAMaker } from 'botbuilder-ai';
import { QnAMakerMetadata } from 'botbuilder-ai';
import { QnARequestContext } from 'botbuilder-ai';
import { RecognizerResult } from 'botbuilder-core';
import { Resource } from 'botbuilder-dialogs-declarative';
import { ResourceExplorer } from 'botbuilder-dialogs-declarative';
import { SkillConversationIdFactoryBase } from 'botbuilder-core';
import { SkillDialog } from 'botbuilder-dialogs';
import { SkillDialogOptions } from 'botbuilder-dialogs';
import { StringExpression } from 'adaptive-expressions';
import { Templates } from 'botbuilder-lg';
import { TokenResponse } from 'botbuilder-core';
import { TurnContext } from 'botbuilder-core';
import { TypeBuilder } from 'botbuilder-dialogs-declarative';
import { ValueExpression } from 'adaptive-expressions';

// @public (undocumented)
export class ActionContext extends DialogContext {
    // Warning: (ae-forgotten-export) The symbol "ActionState" needs to be exported by the entry point index.d.ts
    constructor(dialogs: DialogSet, parentDialogContext: DialogContext, state: DialogState, actions: ActionState[], changeKey: symbol);
    actions: ActionState[];
    applyChanges(): Promise<boolean>;
    // Warning: (ae-forgotten-export) The symbol "ActionChangeList" needs to be exported by the entry point index.d.ts
    readonly changes: ActionChangeList[];
    queueChanges(changes: ActionChangeList): void;
}

// @public (undocumented)
export class ActionScope<O extends object = {}> extends Dialog<O> implements DialogDependencies {
    constructor(actions?: Dialog[]);
    actions: Dialog[];
    // (undocumented)
    protected beginAction(dc: DialogContext, offset: number): Promise<DialogTurnResult>;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    // (undocumented)
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    // (undocumented)
    getDependencies(): Dialog[];
    // (undocumented)
    getVersion(): string;
    // (undocumented)
    protected onActionScopeResult(dc: DialogContext, actionScopeResult: ActionScopeResult): Promise<DialogTurnResult>;
    // (undocumented)
    protected onBreakLoop(dc: DialogContext, actionScopeResult: ActionScopeResult): Promise<DialogTurnResult>;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onContinueLoop(dc: DialogContext, actionScopeResult: ActionScopeResult): Promise<DialogTurnResult>;
    // (undocumented)
    protected onEndOfActions(dc: DialogContext, result?: any): Promise<DialogTurnResult>;
    // (undocumented)
    protected onGotoAction(dc: DialogContext, actionScopeResult: ActionScopeResult): Promise<DialogTurnResult>;
    // (undocumented)
    protected onNextAction(dc: DialogContext, result?: any): Promise<DialogTurnResult>;
    // (undocumented)
    resumeDialog(dc: DialogContext, _reason: DialogReason, result?: any): Promise<DialogTurnResult>;
}

// @public (undocumented)
export enum ActionScopeCommands {
    // (undocumented)
    BreakLoop = "break",
    // (undocumented)
    ContinueLoop = "continue",
    // (undocumented)
    GotoAction = "goto"
}

// @public (undocumented)
export interface ActionScopeResult {
    // (undocumented)
    actionId?: string;
    // (undocumented)
    actionScopeCommand: string;
}

// @public
export class ActivityTemplate implements TemplateInterface<Partial<Activity>> {
    constructor(template: string);
    bind(dialogContext: DialogContext, data: object): Promise<Partial<Activity>>;
    template: string;
    // (undocumented)
    toString: () => string;
}

// @public (undocumented)
export class AdaptiveDialog<O extends object = {}> extends DialogContainer<O> {
    constructor(dialogId?: string);
    autoEndDialog: boolean;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    // (undocumented)
    static conditionTracker: string;
    // (undocumented)
    protected continueActions(dc: DialogContext): Promise<DialogTurnResult>;
    // (undocumented)
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    // (undocumented)
    createChildContext(dc: DialogContext): DialogContext;
    defaultResultProperty: string;
    // (undocumented)
    protected endCurrentAction(actionContext: ActionContext): Promise<boolean>;
    // (undocumented)
    endDialog(turnContext: TurnContext, instance: DialogInstance, reason: DialogReason): Promise<void>;
    // (undocumented)
    protected ensureDependenciesInstalled(): void;
    generator?: LanguageGenerator;
    // (undocumented)
    getDependencies(): Dialog[];
    // (undocumented)
    protected getInternalVersion(): string;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onEndOfActions(actionContext: ActionContext): Promise<DialogTurnResult>;
    // (undocumented)
    protected onPostBubbleEvent(dc: DialogContext, event: DialogEvent): Promise<boolean>;
    // (undocumented)
    protected onPreBubbleEvent(dc: DialogContext, event: DialogEvent): Promise<boolean>;
    // (undocumented)
    protected onRecognize(actionContext: ActionContext, activity: Activity): Promise<RecognizerResult>;
    // (undocumented)
    protected onSetScopedServices(dialogContext: DialogContext): void;
    // (undocumented)
    protected processEvent(actionContext: ActionContext, dialogEvent: DialogEvent, preBubble: boolean): Promise<boolean>;
    recognizer?: Recognizer;
    // (undocumented)
    repromptDialog(context: DialogContext | TurnContext, instance: DialogInstance): Promise<void>;
    // (undocumented)
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    schema: object;
    selector: TriggerSelector;
    triggers: OnCondition[];
    }

// @public (undocumented)
export class AdaptiveDialogComponentRegistration implements ComponentRegistration {
    constructor(resourceExplorer: ResourceExplorer);
    // (undocumented)
    getTypeBuilders(): BuilderRegistration[];
    }

// @public (undocumented)
export class AdaptiveEvents extends DialogEvents {
    static readonly assignEntity = "assignEntity";
    static readonly chooseEntity = "chooseEntity";
    static readonly chooseProperty = "chooseProperty";
    static readonly endOfActions = "endOfActions";
    static readonly recognizedIntent = "recognizedIntent";
    static readonly recognizeUtterance = "recognizeUtterance";
    static readonly unknownIntent = "unknownIntent";
}

// @public (undocumented)
export class AdaptiveTypeBuilder implements TypeBuilder {
    constructor(factory: new () => object, resourceExplorer: ResourceExplorer, converters: {
        [key: string]: Converter;
    });
    // (undocumented)
    build(config: object): object;
    }

// Warning: (ae-forgotten-export) The symbol "TextEntityRecognizer" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class AgeEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export enum ArrayChangeType {
    // (undocumented)
    clear = "clear",
    // (undocumented)
    pop = "pop",
    // (undocumented)
    push = "push",
    // (undocumented)
    remove = "remove",
    // (undocumented)
    take = "take"
}

// @public
export class Ask extends SendActivity {
    constructor(text?: string, expectedProperties?: ArrayExpression<string>);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: object): Promise<DialogTurnResult>;
    defaultOperation: StringExpression;
    expectedProperties: ArrayExpression<string>;
}

// @public (undocumented)
export class AttachmentInput extends InputDialog {
    // (undocumented)
    protected getDefaultInput(dc: DialogContext): any;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onRecognizeInput(dc: DialogContext): Promise<InputState>;
    // (undocumented)
    outputFormat: EnumExpression<AttachmentOutputFormat>;
}

// @public (undocumented)
export enum AttachmentOutputFormat {
    // (undocumented)
    all = "all",
    // (undocumented)
    first = "first"
}

// @public (undocumented)
export class BaseInvokeDialog<O extends object = {}> extends Dialog<O> implements DialogDependencies {
    constructor(dialogIdToCall?: string, bindingOptions?: O);
    activityProcessed: BoolExpression;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult<any>>;
    // (undocumented)
    protected bindOptions(dc: DialogContext, options: object): object;
    dialog: DialogExpression;
    // (undocumented)
    getDependencies(): Dialog<{}>[];
    // (undocumented)
    protected onComputeId(): string;
    options: ObjectExpression<object>;
    // (undocumented)
    protected resolveDialog(dc: DialogContext): Dialog;
}

// @public (undocumented)
export class BeginDialog<O extends object = {}> extends BaseInvokeDialog<O> {
    constructor();
    constructor(dialogIdToCall: string, options?: O);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    resultProperty?: StringExpression;
    // (undocumented)
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
}

// @public (undocumented)
export class BeginSkill extends SkillDialog {
    constructor(options?: SkillDialogOptions);
    activity: TemplateInterface<Partial<Activity>>;
    activityProcessed: BoolExpression;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: BeginSkillDialogOptions): Promise<DialogTurnResult>;
    botId: StringExpression;
    connectionName: StringExpression;
    // (undocumented)
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    endDialog(turnContext: TurnContext, instance: DialogInstance, reason: DialogReason): Promise<void>;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    repromptDialog(turnContext: TurnContext, instance: DialogInstance): Promise<void>;
    resultProperty?: StringExpression;
    // (undocumented)
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult<any>>;
    skillAppId: StringExpression;
    skillEndpoint: StringExpression;
    skillHostEndpoint: StringExpression;
}

// @public (undocumented)
export class BreakLoop<O extends object = {}> extends Dialog<O> {
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// Warning: (ae-forgotten-export) The symbol "CancelAllDialogsBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class CancelAllDialogs<O extends object = {}> extends CancelAllDialogsBase<O> {
    constructor();
    constructor(eventName: string, eventValue?: string);
}

// @public (undocumented)
export class CancelDialog<O extends object = {}> extends CancelAllDialogsBase<O> {
    constructor();
    constructor(eventName: string, eventValue?: string);
}

// @public (undocumented)
export class Case extends ActionScope {
    constructor(value?: string, actions?: Dialog[]);
    createValueExpression(): Expression;
    value: string;
}

// @public (undocumented)
export class CaseConverter implements Converter {
    constructor(resourceExplorer: ResourceExplorer);
    // (undocumented)
    convert(config: {
        value: string;
        actions: Dialog[];
    }): Case;
    }

// @public (undocumented)
export const channels: any;

// @public (undocumented)
export class ChoiceInput extends InputDialog {
    choiceOptions?: ObjectExpression<ChoiceFactoryOptions>;
    choices: ObjectExpression<ChoiceSet>;
    defaultLocale?: StringExpression;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onInitializeOptions(dc: DialogContext, options: ChoiceInputOptions): ChoiceInputOptions;
    // (undocumented)
    protected onRecognizeInput(dc: DialogContext): Promise<InputState>;
    // (undocumented)
    protected onRenderPrompt(dc: DialogContext, state: InputState): Promise<Partial<Activity>>;
    outputFormat: EnumExpression<ChoiceOutputFormat>;
    recognizerOptions?: ObjectExpression<FindChoicesOptions>;
    style: EnumExpression<ListStyle>;
}

// @public (undocumented)
export interface ChoiceInputOptions {
    // (undocumented)
    choices: Choice[];
}

// @public (undocumented)
export enum ChoiceOutputFormat {
    // (undocumented)
    index = "index",
    // (undocumented)
    value = "value"
}

// @public (undocumented)
export class ChoiceSet extends Array<Choice> {
    constructor(obj: any);
}

// @public (undocumented)
export class CodeAction<O extends object = {}> extends Dialog<O> {
    constructor(codeHandler: CodeActionHandler);
    // (undocumented)
    beginDialog(dc: DialogContext, options: O): Promise<DialogTurnResult>;
    // (undocumented)
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export type CodeActionHandler = (dc: DialogContext, options?: object) => Promise<DialogTurnResult>;

// @public
export class ConditionalSelector implements TriggerSelector {
    condition: BoolExpression;
    ifFalse: TriggerSelector;
    ifTrue: TriggerSelector;
    // (undocumented)
    initialize(conditionals: OnCondition[], evaluate: boolean): void;
    parser: ExpressionParserInterface;
    // (undocumented)
    select(actionContext: ActionContext): Promise<number[]>;
}

// @public (undocumented)
export class ConfirmationEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class ConfirmInput extends InputDialog {
    choiceOptions?: ObjectExpression<ChoiceFactoryOptions>;
    confirmChoices?: ObjectExpression<ChoiceSet>;
    defaultLocale?: StringExpression;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onRecognizeInput(dc: DialogContext): Promise<InputState>;
    // (undocumented)
    protected onRenderPrompt(dc: DialogContext, state: InputState): Promise<Partial<Activity>>;
    outputFormat: StringExpression;
    style: EnumExpression<ListStyle>;
}

// @public (undocumented)
export class ContinueLoop<O extends object = {}> extends Dialog<O> {
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export function createRecognizerResult(text: string, intents?: IntentMap, entities?: object): RecognizerResult;

// @public
export class CrossTrainedRecognizerSet extends Recognizer {
    recognize(dialogContext: DialogContext, activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }, telemetryMetrics?: {
        [key: string]: number;
    }): Promise<RecognizerResult>;
    recognizers: Recognizer[];
}

// @public (undocumented)
export class CurrencyEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class DateTimeEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class DateTimeInput extends InputDialog {
    // (undocumented)
    defaultLocale: StringExpression;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onRecognizeInput(dc: DialogContext): Promise<InputState>;
    // (undocumented)
    outputFormat: StringExpression;
}

// @public (undocumented)
export class DeleteActivity<O extends object = {}> extends Dialog<O> {
    constructor();
    activityId: StringExpression;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export class DeleteProperties<O extends object = {}> extends Dialog<O> {
    constructor();
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
    properties: StringExpression[];
}

// @public (undocumented)
export class DeleteProperty<O extends object = {}> extends Dialog<O> {
    constructor();
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
    property: StringExpression;
}

// @public
export class DialogExpression extends ExpressionProperty<Dialog> {
    constructor(value?: Dialog | string | Expression);
    // (undocumented)
    setValue(value: Dialog | string | Expression): void;
}

// @public (undocumented)
export class DialogExpressionConverter implements Converter {
    constructor(resouceExplorer: ResourceExplorer);
    // (undocumented)
    convert(value: string | object): DialogExpression;
    }

// @public (undocumented)
export class DimensionEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class DynamicBeginDialog extends BeginDialog {
    // (undocumented)
    protected bindOptions(dc: DialogContext, options: object): object;
}

// @public (undocumented)
export class EditActions<O extends object = {}> extends Dialog<O> implements DialogDependencies {
    constructor();
    // Warning: (ae-forgotten-export) The symbol "ActionChangeType" needs to be exported by the entry point index.d.ts
    constructor(changeType: ActionChangeType, actions?: Dialog[]);
    actions: Dialog[];
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    changeType: EnumExpression<ActionChangeType>;
    disabled?: BoolExpression;
    // (undocumented)
    getDependencies(): Dialog[];
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export class EditArray<O extends object = {}> extends Dialog<O> {
    constructor();
    constructor(changeType: ArrayChangeType, itemsProperty: string, value?: any, resultProperty?: string);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    changeType: EnumExpression<ArrayChangeType>;
    disabled?: BoolExpression;
    itemsProperty: StringExpression;
    // (undocumented)
    protected onComputeId(): string;
    resultProperty: StringExpression;
    value: ValueExpression;
}

// @public (undocumented)
export class EmailEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class EmitEvent<O extends object = {}> extends Dialog<O> {
    constructor();
    constructor(eventName: string, eventValue?: string, bubbleEvent?: boolean);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    bubbleEvent: BoolExpression;
    disabled?: BoolExpression;
    eventName: StringExpression;
    eventValue: ValueExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export class EndDialog<O extends object = {}> extends Dialog<O> {
    constructor();
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected endParentDialog(dc: DialogContext, result?: any): Promise<DialogTurnResult>;
    // (undocumented)
    protected onComputeId(): string;
    value: ValueExpression;
}

// @public (undocumented)
export class EndTurn<O extends object = {}> extends Dialog<O> {
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    // (undocumented)
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export interface EntityRecognizer {
    // (undocumented)
    recognizeEntities(dialogContext: DialogContext, text: string, locale: string, entities: Entity[]): Promise<Entity[]>;
}

// @public (undocumented)
export class EntityRecognizerSet extends Array<EntityRecognizer> {
    // (undocumented)
    recognizeEntities(dialogContext: DialogContext, text: string, locale: string, entities?: Entity[]): Promise<Entity[]>;
}

// @public
export class FirstSelector implements TriggerSelector {
    // (undocumented)
    initialize(conditionals: OnCondition[], evaluate: boolean): void;
    parser: ExpressionParserInterface;
    // (undocumented)
    select(actionContext: ActionContext): Promise<number[]>;
}

// @public (undocumented)
export class ForEach<O extends object = {}> extends ActionScope<O> {
    constructor();
    constructor(itemsProperty: string, actions: Dialog[]);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    getDependencies(): Dialog[];
    index: StringExpression;
    itemsProperty: StringExpression;
    // (undocumented)
    protected nextItem(dc: DialogContext): Promise<DialogTurnResult>;
    // (undocumented)
    protected onBreakLoop(dc: DialogContext, actionScopeResult: ActionScopeResult): Promise<DialogTurnResult>;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onContinueLoop(dc: DialogContext, actionScopeResult: ActionScopeResult): Promise<DialogTurnResult>;
    // (undocumented)
    protected onEndOfActions(dc: DialogContext, result?: any): Promise<DialogTurnResult>;
    value: StringExpression;
}

// @public
export class ForEachPage<O extends object = {}> extends ActionScope<O> {
    constructor();
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    getDependencies(): Dialog[];
    itemsProperty: StringExpression;
    // (undocumented)
    protected onBreakLoop(dc: DialogContext, actionScopeResult: ActionScopeResult): Promise<DialogTurnResult>;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onContinueLoop(dc: DialogContext, actionScopeResult: ActionScopeResult): Promise<DialogTurnResult>;
    // (undocumented)
    protected onEndOfActions(dc: DialogContext, result?: any): Promise<DialogTurnResult>;
    page: StringExpression;
    pageIndex: StringExpression;
    pageSize: IntExpression;
}

// @public (undocumented)
export class GetActivityMembers<O extends object = {}> extends Dialog {
    constructor();
    activityId: StringExpression;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
    property: StringExpression;
}

// @public (undocumented)
export class GetConversationMembers<O extends object = {}> extends Dialog<O> {
    constructor();
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
    property: StringExpression;
}

// @public (undocumented)
export class GotoAction<O extends object = {}> extends Dialog<O> {
    constructor();
    actionId: StringExpression;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export class GuidEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class HashtagEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class HttpHeadersConverter implements Converter {
    // (undocumented)
    convert(value: object): {
        [key: string]: StringExpression;
    };
}

// @public (undocumented)
export enum HttpMethod {
    DELETE = "DELETE",
    GET = "GET",
    PATCH = "PATCH",
    POST = "POST",
    PUT = "PUT"
}

// @public (undocumented)
export class HttpRequest<O extends object = {}> extends Dialog<O> implements Configurable {
    constructor();
    constructor(method: HttpMethod, url: string, headers: {
        [key: string]: string;
    }, body: any);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    body?: ValueExpression;
    contentType?: StringExpression;
    disabled?: BoolExpression;
    headers?: {
        [key: string]: StringExpression;
    };
    method?: HttpMethod;
    // (undocumented)
    protected onComputeId(): string;
    responseType?: EnumExpression<ResponsesTypes>;
    resultProperty?: StringExpression;
    url?: StringExpression;
}

// @public (undocumented)
export class IfCondition<O extends object = {}> extends Dialog<O> implements DialogDependencies {
    constructor();
    actions: Dialog[];
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    condition: BoolExpression;
    disabled?: BoolExpression;
    elseActions: Dialog[];
    // (undocumented)
    protected readonly falseScope: ActionScope;
    // (undocumented)
    getDependencies(): Dialog[];
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected readonly trueScope: ActionScope;
    }

// @public (undocumented)
export abstract class InputDialog extends Dialog {
    constructor(property?: string, prompt?: Partial<Activity> | string);
    allowInterruptions: BoolExpression;
    alwaysPrompt: BoolExpression;
    protected appendChoices(prompt: Partial<Activity>, channelId: string, choices: Choice[], style: ListStyle, options?: ChoiceFactoryOptions): Partial<Activity>;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: any): Promise<DialogTurnResult>;
    // (undocumented)
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    defaultValue?: ValueExpression;
    defaultValueResponse: TemplateInterface<Partial<Activity>>;
    disabled?: BoolExpression;
    // (undocumented)
    protected getDefaultInput(dc: DialogContext): any;
    invalidPrompt: TemplateInterface<Partial<Activity>>;
    maxTurnCount?: IntExpression;
    // (undocumented)
    protected onInitializeOptions(dc: DialogContext, options: any): any;
    // (undocumented)
    protected onPreBubbleEvent(dc: DialogContext, event: DialogEvent): Promise<boolean>;
    // (undocumented)
    protected abstract onRecognizeInput(dc: DialogContext): Promise<InputState>;
    // (undocumented)
    protected onRenderPrompt(dc: DialogContext, state: InputState): Promise<Partial<Activity>>;
    // (undocumented)
    static OPTIONS_PROPERTY: string;
    prompt: TemplateInterface<Partial<Activity>>;
    property: StringExpression;
    // (undocumented)
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    // (undocumented)
    static TURN_COUNT_PROPERTY: string;
    unrecognizedPrompt: TemplateInterface<Partial<Activity>>;
    validations: string[];
    value: ValueExpression;
    // (undocumented)
    static VALUE_PROPERTY: string;
}

// @public (undocumented)
export enum InputState {
    // (undocumented)
    invalid = "invalid",
    // (undocumented)
    missing = "missing",
    // (undocumented)
    unrecognized = "unrecognized",
    // (undocumented)
    valid = "valid"
}

// @public (undocumented)
export interface IntentMap {
    // (undocumented)
    [name: string]: {
        score: number;
    };
}

// @public (undocumented)
export class IntentPattern {
    constructor(intent?: string, pattern?: string);
    // (undocumented)
    intent: string;
    // (undocumented)
    pattern: string;
    // (undocumented)
    readonly regex: RegExp;
}

// @public (undocumented)
export class IntentPatternConverter implements Converter {
    // (undocumented)
    convert(value: {
        intent: string;
        pattern: string;
    }): IntentPattern;
}

// @public (undocumented)
export class IpEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public
export interface LanguageGenerator {
    generate(dialogContext: DialogContext, template: string, data: object): Promise<string>;
}

// @public
export class LanguageGeneratorExtensions {
    static useLanguageGeneration(dialogManager: DialogManager, lg?: string | LanguageGenerator): DialogManager;
    static useLanguagePolicy(dialogManager: DialogManager, policy: LanguagePolicy): DialogManager;
}

// @public
export const languageGeneratorKey: unique symbol;

// @public
export class LanguageGeneratorManager {
    constructor(resourceManager: ResourceExplorer);
    languageGenerators: Map<string, LanguageGenerator>;
    // (undocumented)
    static resourceExplorerResolver(locale: string, resourceMapping: Map<string, Resource[]>): ImportResolverDelegate;
    }

// @public
export const languageGeneratorManagerKey: unique symbol;

// @public
export class LanguagePolicy extends Map<string, string[]> {
    constructor(...defaultLanguages: string[]);
    // (undocumented)
    static defaultPolicy(defaultLanguages?: string[]): Map<string, string[]>;
    // (undocumented)
    static readonly locales: string[];
}

// @public (undocumented)
export class LanguagePolicyConverter implements Converter {
    // (undocumented)
    convert(value: object): LanguagePolicy;
}

// @public
export const languagePolicyKey: unique symbol;

// @public
export class LanguageResourceLoader {
    static fallbackLocale(locale: string, optionalLocales: string[]): string;
    static groupByLocale(resourceExplorer: ResourceExplorer): Map<string, Resource[]>;
    static parseLGFileName(lgFileName: string): {
        prefix: string;
        language: string;
    };
}

// @public (undocumented)
export class LogAction<O extends object = {}> extends Dialog<O> {
    constructor();
    constructor(text: string);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    label: StringExpression;
    // (undocumented)
    protected onComputeId(): string;
    text: TemplateInterface<string>;
    traceActivity: BoolExpression;
}

// @public (undocumented)
export class LuisAdaptiveRecognizer extends Recognizer {
    applicationId: StringExpression;
    dynamicLists: ArrayExpression<any>;
    endpoint: StringExpression;
    endpointKey: StringExpression;
    protected fillRecognizerResultTelemetryProperties(recognizerResult: RecognizerResult, telemetryProperties: {
        [key: string]: string;
    }, dialogContext: DialogContext): {
        [key: string]: string;
    };
    logPersonalInformation: BoolExpression;
    predictionOptions: LuisPredictionOptions;
    // (undocumented)
    recognize(dialogContext: DialogContext, activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }, telemetryMetrics?: {
        [key: string]: number;
    }): Promise<RecognizerResult>;
    recognizerOptions(dialogContext: DialogContext): LuisRecognizerOptionsV3;
}

// @public (undocumented)
export class MentionEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public
export class MultiLanguageGenerator extends MultiLanguageGeneratorBase {
    languageGenerators: Map<string, LanguageGenerator>;
    tryGetGenerator(dialogContext: DialogContext, locale: string): {
        exist: boolean;
        result: LanguageGenerator;
    };
}

// @public
export abstract class MultiLanguageGeneratorBase implements LanguageGenerator {
    generate(dialogContext: DialogContext, template: string, data: object): Promise<string>;
    languagePolicy: LanguagePolicy;
    abstract tryGetGenerator(dialogContext: DialogContext, locale: string): {
        exist: boolean;
        result: LanguageGenerator;
    };
}

// @public (undocumented)
export class MultiLanguageRecognizer extends Recognizer {
    // (undocumented)
    languagePolicy: LanguagePolicy;
    // (undocumented)
    recognize(dialogContext: DialogContext, activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }, telemetryMetrics?: {
        [key: string]: number;
    }): Promise<RecognizerResult>;
    // (undocumented)
    recognizers: {
        [locale: string]: Recognizer;
    };
}

// @public (undocumented)
export class NumberEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class NumberInput extends InputDialog {
    // (undocumented)
    defaultLocale?: StringExpression;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onRecognizeInput(dc: DialogContext): Promise<InputState>;
    // (undocumented)
    outputFormat?: NumberExpression;
}

// @public (undocumented)
export class OAuthInput extends InputDialog {
    constructor(connectionName?: string, title?: string, text?: string, timeout?: number);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: PromptOptions): Promise<DialogTurnResult>;
    connectionName: StringExpression;
    // (undocumented)
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    getUserToken(dc: DialogContext, code?: string): Promise<TokenResponse | undefined>;
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onRecognizeInput(dc: DialogContext): Promise<InputState>;
    signOutUser(dc: DialogContext): Promise<void>;
    text?: StringExpression;
    timeout?: IntExpression;
    title: StringExpression;
}

// @public
export class OnActivity extends OnDialogEvent {
    constructor(type?: string, actions?: Dialog[], condition?: string);
    // (undocumented)
    getExpression(parser: ExpressionParserInterface): Expression;
    type: string;
}

// @public
export class OnAssignEntity extends OnDialogEvent {
    constructor(property?: string, entity?: string, operation?: string, actions?: Dialog[], condition?: string);
    entity: string;
    // (undocumented)
    getExpression(parser: ExpressionParserInterface): Expression;
    operation: string;
    property: string;
}

// @public
export class OnBeginDialog extends OnDialogEvent {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnCancelDialog extends OnDialogEvent {
    constructor(actions?: Dialog[], condtion?: string);
}

// @public
export class OnChooseEntity extends OnDialogEvent {
    constructor(property?: string, entity?: string, actions?: Dialog[], condition?: string);
    entity: string;
    // (undocumented)
    getExpression(parser: ExpressionParserInterface): Expression;
    property: string;
}

// @public (undocumented)
export class OnChooseIntent extends OnIntent {
    constructor(actons?: Dialog[], condition?: string);
    // (undocumented)
    getExpression(parser: ExpressionParserInterface): Expression;
    // (undocumented)
    intents: string[];
}

// @public
export class OnChooseProperty extends OnDialogEvent {
    constructor(properties?: string[], entities?: string[], actions?: Dialog[], condition?: string);
    entities: string[];
    // (undocumented)
    getExpression(parser: ExpressionParserInterface): Expression;
    properties: string[];
}

// @public (undocumented)
export class OnCondition implements DialogDependencies {
    constructor(condition?: string, actions?: Dialog[]);
    actions: Dialog[];
    // (undocumented)
    protected readonly actionScope: ActionScope;
    addExternalCondition(condition: string): void;
    condition: BoolExpression;
    currentPriority(actionContext: ActionContext): number;
    execute(actionContext: ActionContext): Promise<ActionChangeList[]>;
    getDependencies(): Dialog[];
    getExpression(parser: ExpressionParserInterface): Expression;
    id: string;
    // (undocumented)
    protected onCreateChangeList(actionContext: ActionContext, dialogOptions?: any): ActionChangeList;
    priority: IntExpression;
    runOnce: boolean;
}

// @public
export class OnConversationUpdateActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnDialogEvent extends OnCondition {
    constructor(event?: string, actions?: Dialog[], condition?: string);
    event: string;
    // (undocumented)
    getExpression(parser: ExpressionParserInterface): Expression;
}

// @public
export class OnEndOfActions extends OnDialogEvent {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnEndOfConversationActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnError extends OnDialogEvent {
    constructor(actions?: Dialog[], condition?: string);
    // (undocumented)
    onCreateChangeList(actionContext: ActionContext, dialogOptions?: any): ActionChangeList;
}

// @public
export class OnEventActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public (undocumented)
export class OnHandoffActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnIntent extends OnDialogEvent {
    constructor(intent?: string, entities?: string[], actions?: Dialog[], condition?: string);
    entities: string[];
    // (undocumented)
    getExpression(parser: ExpressionParserInterface): Expression;
    intent: string;
    // (undocumented)
    protected onCreateChangeList(actionContext: ActionContext, dialogOptions?: any): ActionChangeList;
}

// @public
export class OnInvokeActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnMessageActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnMessageDeleteActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnMessageReactionActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnMessageUpdateActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnQnAMatch extends OnIntent {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnRepromptDialog extends OnDialogEvent {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnTypingActivity extends OnActivity {
    constructor(actions?: Dialog[], condition?: string);
}

// @public
export class OnUnknownIntent extends OnDialogEvent {
    constructor(actions?: Dialog[], condition?: string);
}

// @public (undocumented)
export class OrdinalEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class PercentageEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class PhoneNumberEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export interface PropertyAssignment {
    // (undocumented)
    property: StringExpression;
    // (undocumented)
    value: ValueExpression;
}

// @public (undocumented)
export class PropertyAssignmentConverter implements Converter {
    // (undocumented)
    convert(assignment: {
        property: string;
        value: any;
    }): PropertyAssignment;
}

// @public
export class PropertySchema {
    constructor(path: string, schema: object, children?: PropertySchema[]);
    readonly children: PropertySchema[];
    readonly entities: string[];
    readonly expectedOnly: string[];
    isArray(): boolean;
    isEnum(): boolean;
    readonly name: string;
    readonly parent: PropertySchema | undefined;
    readonly path: string;
    readonly schema: object;
    readonly type: string;
}

// @public
export class QnAMakerRecognizer extends Recognizer {
    constructor(hostname?: string, knowledgeBaseId?: string, endpointKey?: string);
    context: ObjectExpression<QnARequestContext>;
    endpointKey: StringExpression;
    protected getQnAMaker(dc: DialogContext): QnAMaker;
    hostname: StringExpression;
    includeDialogNameInMetadata: BoolExpression;
    isTest: boolean;
    knowledgeBaseId: StringExpression;
    metadata: ArrayExpression<QnAMakerMetadata>;
    qnaId: IntExpression;
    // (undocumented)
    static readonly qnaMatchIntent = "QnAMatch";
    rankerType: StringExpression;
    recognize(dc: DialogContext, activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }, telemetryMetrics?: {
        [key: string]: number;
    }): Promise<RecognizerResult>;
    threshold: NumberExpression;
    top: IntExpression;
}

// @public
export class RandomSelector implements TriggerSelector {
    // (undocumented)
    initialize(conditionals: OnCondition[], evaluate: boolean): void;
    parser: ExpressionParserInterface;
    // (undocumented)
    select(actionContext: ActionContext): Promise<number[]>;
}

// @public (undocumented)
export class Recognizer {
    protected fillRecognizerResultTelemetryProperties(recognizerResult: RecognizerResult, telemetryProperties: {
        [key: string]: string;
    }, dialogContext?: DialogContext): {
        [key: string]: string;
    };
    id: string;
    recognize(dialogContext: DialogContext, activity: Partial<Activity>, telemetryProperties?: {
        [key: string]: string;
    }, telemetryMetrics?: {
        [key: string]: number;
    }): Promise<RecognizerResult>;
    telemetryClient: BotTelemetryClient;
    protected _telemetryClient: BotTelemetryClient;
    // (undocumented)
    protected trackRecognizerResult(dialogContext: DialogContext, eventName: string, telemetryProperties?: {
        [key: string]: string;
    }, telemetryMetrics?: {
        [key: string]: number;
    }): void;
}

// @public (undocumented)
export class RecognizerSet extends Recognizer {
    // (undocumented)
    recognize(dialogContext: DialogContext, activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }, telemetryMetrics?: {
        [key: string]: number;
    }): Promise<RecognizerResult>;
    // (undocumented)
    recognizers: Recognizer[];
}

// @public
export class RegexEntityRecognizer extends TextEntityRecognizer {
    constructor();
    // (undocumented)
    name: string;
    // (undocumented)
    pattern: string;
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public (undocumented)
export class RegexRecognizer extends Recognizer {
    entities: EntityRecognizer[];
    intents: IntentPattern[];
    // (undocumented)
    recognize(dialogContext: DialogContext, activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }, telemetryMetrics?: {
        [key: string]: number;
    }): Promise<RecognizerResult>;
}

// @public (undocumented)
export class RepeatDialog<O extends object = {}> extends BaseInvokeDialog<O> {
    constructor();
    allowLoop?: BoolExpression;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
}

// @public (undocumented)
export class ReplaceDialog<O extends object = {}> extends BaseInvokeDialog<O> {
    constructor();
    constructor(dialogIdToCall: string, options?: O);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
}

// @public
export const resourceExplorerKey: unique symbol;

// @public
export class ResourceExtensions {
    static useResourceExplorer(dialogManager: DialogManager, resourceExplorer: ResourceExplorer): DialogManager;
}

// @public (undocumented)
export class ResourceMultiLanguageGenerator extends MultiLanguageGeneratorBase {
    constructor(resourceId?: string);
    resourceId: string;
    tryGetGenerator(dialogContext: DialogContext, locale: string): {
        exist: boolean;
        result: LanguageGenerator;
    };
}

// @public (undocumented)
export enum ResponsesTypes {
    Activities = 3,
    Activity = 2,
    Binary = 4,
    Json = 1,
    None = 0
}

// @public
export class Result {
    constructor(headers?: Headers_2);
    content?: any;
    headers?: {
        [key: string]: string;
    };
    reasonPhrase?: string;
    statusCode?: number;
}

// @public
export class SchemaHelper {
    constructor(schema: object);
    pathToSchema(path: string): PropertySchema | undefined;
    readonly property: PropertySchema;
    readonly required: string[];
    readonly schema: object;
}

// @public (undocumented)
export class SendActivity<O extends object = {}> extends Dialog<O> {
    constructor(activity?: Partial<Activity> | string);
    activity: TemplateInterface<Partial<Activity>>;
    // (undocumented)
    beginDialog(dc: DialogContext, options: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export class SetProperties<O extends object = {}> extends Dialog<O> {
    constructor();
    assignments: PropertyAssignment[];
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export class SetProperty<O extends object = {}> extends Dialog<O> {
    constructor();
    constructor(property: string, value: any);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
    property: StringExpression;
    value: ValueExpression;
}

// @public (undocumented)
export class SignOutUser<O extends object = {}> extends Dialog<O> {
    constructor();
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    connectionName: StringExpression;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
    userId: StringExpression;
}

// @public
export const skillClientKey: unique symbol;

// @public
export const skillConversationIdFactoryKey: unique symbol;

// @public
export class SkillExtensions {
    static useSkillClient(dialogManager: DialogManager, skillClient: BotFrameworkClient): DialogManager;
    static useSkillConversationIdFactory(dialogManager: DialogManager, skillConversationIdFactory: SkillConversationIdFactoryBase): DialogManager;
}

// @public
export class StaticActivityTemplate implements TemplateInterface<Partial<Activity>> {
    constructor(activity?: Partial<Activity>);
    activity: Partial<Activity>;
    bind(dialogContext: DialogContext, data: object): Promise<Partial<Activity>>;
    // (undocumented)
    toString: () => string;
}

// @public (undocumented)
export class SwitchCondition<O extends object = {}> extends Dialog<O> implements DialogDependencies {
    constructor();
    constructor(condition: string, defaultDialogs: Dialog[], cases: Case[]);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    cases: Case[];
    condition: Expression;
    default: Dialog[];
    // (undocumented)
    protected readonly defaultScope: ActionScope;
    disabled?: BoolExpression;
    // (undocumented)
    getDependencies(): Dialog[];
    // (undocumented)
    protected onComputeId(): string;
}

// @public
export const telemetryClientKey: unique symbol;

// @public (undocumented)
export class TemperatureEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public
export class TemplateEngineLanguageGenerator implements LanguageGenerator {
    constructor(arg1?: Templates | string, arg2?: string | Map<string, Resource[]>, arg3?: Map<string, Resource[]>);
    // (undocumented)
    generate(dialogContext: DialogContext, template: string, data: object): Promise<string>;
    // (undocumented)
    id: string;
    }

// @public
export interface TemplateInterface<T> {
    bind(dialogContext: DialogContext, data?: object): Promise<T>;
}

// @public (undocumented)
export class TextEntity implements Entity {
    constructor(text?: string);
    // (undocumented)
    text: string;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export class TextInput extends InputDialog {
    // (undocumented)
    protected onComputeId(): string;
    // (undocumented)
    protected onRecognizeInput(dc: DialogContext): Promise<InputState>;
    // (undocumented)
    outputFormat: StringExpression;
}

// @public
export class TextTemplate implements TemplateInterface<string> {
    constructor(template: string);
    bind(dialogContext: DialogContext, data: object): Promise<string>;
    template: string;
    // (undocumented)
    toString: () => string;
}

// @public (undocumented)
export class TraceActivity<O extends object = {}> extends Dialog<O> {
    constructor();
    constructor(name: string, valueType: string, value: any, label: string);
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    label?: StringExpression;
    name?: StringExpression;
    // (undocumented)
    protected onComputeId(): string;
    value?: ValueExpression;
    valueType?: StringExpression;
}

// @public
export interface TriggerSelector {
    initialize(conditionHandlers: OnCondition[], evaluate: boolean): void;
    parser: ExpressionParserInterface;
    select(actionContext: ActionContext): Promise<number[]>;
}

// @public
export class TrueSelector implements TriggerSelector {
    // (undocumented)
    initialize(conditionals: OnCondition[], evaluate: boolean): void;
    parser: ExpressionParserInterface;
    // (undocumented)
    select(actionContext: ActionContext): Promise<number[]>;
}

// @public (undocumented)
export class UpdateActivity<O extends object = {}> extends Dialog<O> {
    constructor();
    activity: TemplateInterface<Partial<Activity>>;
    activityId: StringExpression;
    // (undocumented)
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    disabled?: BoolExpression;
    // (undocumented)
    protected onComputeId(): string;
}

// @public (undocumented)
export class UrlEntityRecognizer extends TextEntityRecognizer {
    // (undocumented)
    protected recognize(text: string, culture: string): ModelResult[];
}

// @public
export function useTelemetry(dialogManager: DialogManager, telemetryClient: BotTelemetryClient): DialogManager;


// (No @packageDocumentation comment for this package)

```
